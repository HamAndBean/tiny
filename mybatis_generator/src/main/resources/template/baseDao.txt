package ${table.thisEntity.daoPackage};

import com.google.common.reflect.TypeToken;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import ${table.thisEntity.mapperName};
import ${table.thisEntity.name};

import java.util.*;

public abstract class ${table.thisEntity.daoSimpleName}<Entity extends ${table.thisEntity.simpleName}<Entity>, Mapper extends ${table.thisEntity.mapperSimpleName}<Entity>>
        implements ${table.thisEntity.mapperSimpleName}<Entity> {
    private Logger logger = LoggerFactory.getLogger( getClass() );

    private Mapper baseMapper;
    private Class<Mapper> baseMapperCls;

    private SqlSessionFactory sessionFactory;

    @SuppressWarnings( "unchecked" )
    protected void setBaseMapper( Mapper baseMapper ) {
        this.baseMapper = baseMapper;

        // Get origin mapper by guava type token
        TypeToken<Mapper> mapperTypeToken = new TypeToken<Mapper>( getClass() ) {};
        this.baseMapperCls = ( Class<Mapper> ) mapperTypeToken.getRawType();
    }

    @Autowired
    public void setSessionFactory( SqlSessionFactory sessionFactory ) {
        this.sessionFactory = sessionFactory;
    }

    @Override
    public Entity query( String id ) {
        return baseMapper.query( id );
    }

    @Override
    public List<Entity> queryAll( int beginRow, int row, int status ) {
        return baseMapper.queryAll( beginRow, row, status );
    }

    @Override
    public List<Entity> queryBySpecificId( Collection<String> ids, int beginRow, int row, int status ) {
        return baseMapper.queryBySpecificId( ids, beginRow, row, status );
    }

    @Override
    public int save( Entity entity ) {
        return baseMapper.save( entity );
    }

    @Override
    public int saveAll( Collection<Entity> entities ) {
        return baseMapper.saveAll( entities );
    }

    @Override
    public int update( Entity entity ) {
        #if( "Date" == ${timeUnit} )
        return baseMapper.update( entity.setUpdateTime( new Date() ) );
        #else
        return baseMapper.update( entity.setUpdateTime( System.currentTimeMillis() ) );
        #end
    }

    public int updateAll( Collection<Entity> entities ) {
        SqlSession session = sessionFactory.openSession();

        // Cannot just get mapper proxy by baseMapper.getClass() because the base mapper already been proxy, it is a proxy class!
        // Session will throw a exception if find proxy by a proxy class
        Mapper mapper = session.getMapper( baseMapperCls );

        try {
            #if( "Date" == ${timeUnit} )
            entities.forEach( entity -> mapper.update( entity.setUpdateTime( new Date() ) ) );
            #else
            entities.forEach( entity -> mapper.update( entity.setUpdateTime( System.currentTimeMillis() ) ) );
            #end

            int effectRow = session.flushStatements().size();
            session.commit();

            return effectRow;

        } catch ( Exception e ) {
            logger.error( "Batch update failure.", e );
            session.rollback();

        } finally {
            session.clearCache();
            session.close();
        }

        return 0;
    }

    @Override
    public int specificUpdate( String id, ${timeUnit} updateTime, Map<String, Object> fieldAndValues ) {
        return baseMapper.specificUpdate( id, updateTime, fieldAndValues );
    }

    @Override
    public int remove( String id, ${timeUnit} deleteTime ) {
        return baseMapper.remove( id, deleteTime );
    }

    @Override
    public int removeAll( Collection<String> ids, ${timeUnit} deleteTime ) {
        return baseMapper.removeAll( ids, deleteTime );
    }

    @Override
    public int physicalDelete( String id ) {
        throw new UnsupportedOperationException( "PhysicalDelete function already banned. ( If you want to open please modify the source code )" );
    }

    @Override
    public int physicalDeleteAll( Collection<String> ids ) {
        throw new UnsupportedOperationException( "PhysicalDeleteAll function already banned. ( If you want to open please modify the source code )" );
    }
}
