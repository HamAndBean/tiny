###  itfinally project
#### 一个为加快开发速度而开发的项目

#### 大家好, 人称前言的便是区区在下

这个项目的所有子模块都是出自作者在开发过程中遇到的一些重复处理的问题,
因而收集起来写成模块, 基于此模块下只需要关心自己的需求即可.

当然网上也有很多现成的 OA 类框架, 但是恕我直言, 无论对外说的多好多美, 
只要你看一眼代码就知道其实都是那副德性( 好吧看过真的给恶心到了才这么说 ), 
而且大部分都是集成老一套的 jsp 或模版技术, 更有甚者写出各种奇奇怪怪的 javascript, 
嵌套各种 iframe, 令人陷进神一样的 iframe 间通讯问题, 难以维护, 
甚至为了填坑创造出更多的坑. ( 还有用一长串 if-elif-else 写 mvc dispatcher 的我会说? )

我觉得一个好的后台框架, 是不应该涉及到前端的, 专心做好后台的事, 尽力最到最好.

基于此, 萌生了以 spring-boot 为基础来编写一系列工具的想法, 
当然是不会再顾及 jsp 这种强耦合还不利于调试的设计方式, 上面说得很清楚了.
后期也会编写前端, 抽象出一整套以 vue 做为基础的前端平台, 不过主要是给自己用的啦.

噢, 每个子模块的存在问题( 也就是作者尚未解决的问题 ), 设计思路, 以及为什么这么做的说明
都会以 README.md 的形式放在模块根目录下.

#### 各单位注意, 前言已经去领便当了, 我是正文

项目创建的时候是 18年10月, 结果没过多久 Java9 出来了, 据描述是不兼容 9 以下的版本的.
这个看什么时候玩玩 Java9, 把模块依赖描述也加进去.

整个项目会以模块的形式使用 maven 辅助合并编译, 因为所有业务模块均依赖
core ( 基础工具及类库 ) & parent ( 基础pom ) 两个子模块.

项目说明:
* 这里先说说为何选用 myBatis.

  主要是 mybatis 可以写 sql, hibernate 的 criteria 对象也很灵活这我造, 然而还是喜欢写 sql,
  毕竟可以清楚知道自己在干什么, 而且可以针对性写一些 sql hook, 看着也比 api 操作清晰.
  
  当然 mybatis 直接的缺点就是自动化程度太低, 所以所有项目都改用 dao/mapper 重新封装一次, 
  除了新增接口外, 所有操作直接面向 api, 当然该项目也写了一个生成器, 负责生成 dao/mapper/xml-mapper 等文件, 叫 mybatis_generator.
  
* 选用 mysql 是因为这货在大部分开发中都是首选, 份额也是最大的, 直接选用.
  所以整个项目都是仅针对 mysql 的, 如果有其他 db 的需求, 那只能自己修改对应模块内的 xml 啦.( 没错, sql 都写在 xml 里面 )
  
* 所有涉及到的 url 均采用 restful 风格.( 其实没做的那么符合风格, 比如删除就不会做成接收 DELETE 请求 )

* 所有涉及到前端请求交互的载体都继承于 core 模块的 vo.BaseVoBean 类.

* 所有涉及到数据库交互的实体类都继承于 core 模块的 repository.po.BaseEntity 类.

* 所有实体均采用 builder 模式的编写风格, 好歹也提高提下键盘寿命. 关于实体类是否应该使用 void 返回, 这里还有一些 sof 论坛的讨论
  [Does Java bean's setter permit return this?](https://stackoverflow.com/questions/5741369/does-java-beans-setter-permit-return-this),
  因为 jdk 自带的 Introspector, 以及 apache 名下的 BeanUtils 都不会识别 non-void 类型的 setter, 有意思的是 spring 的 ExtendedBeanInfoFactory 
  支持这一类型的 setter( 其实早在以前 spring 也是不支持的, 在 sof 里搜索 <strong>java non-void setter</strong> 会找到很多相关的讨论 ), 
  当然我也是支持使用这种 non-void 的 setter, 毕竟在构造器上写一堆密密麻麻的形参实在是丑的不行, 当然这个也是各有所爱了.

* 秉承 linux 那句 "没有消息就是好消息". 一般在编写时考虑到的问题都会写在文档上, 如果没有说明, 那一般是没问题. 
  如果碰到并且确认是个 bug, 记得带上砖头来 issues 找作者拍砖.
  
* 时间均采用机器时间, 连带数据库的数据类型为长整型, 存储应该和展示分离, 不受时区影响.

* 默认约定数据的状态, -1 为已删除, 1 为正常, 且不存在 0 这种特殊数字, 所有删除行为均为逻辑删除.
  ( 其实也有提供物理删除, 但是已经重写基类进行禁用, 强行调用会直接抛异常, 在 `top.itfinally.core.repository.dao.AbstractDao` 内,
   有需要的自行修改再编译打包 )
   
* 尽量遵循函数式编程风格以便减少共享变量和拆分问题, 尽可能做到变量/对象的状态不可变. 当然有些场景在 java 里依然不可能
  做到不可变, 比如迭代的时候需要当前元素的下表, 诸如 python 之类的语言可以很简单的利用官方提供的 enumerate 做到这一点, 
  但是 java 并不存在这种东西, 所以要么写一个自己的 forEach, 要么更改变量的值.
   
整个项目开发基于以下版本/工具/框架:
* IntelliJ IDEA ( 一个好用的工具真的事半功倍, 可破解, 反正我搞了个全家桶233 ( MMD 好TM贵 T _ T, 真没收广告费 )
* Java 1.8      ( 抱歉, 用完 stream 的那一刻就不想向下兼容了, 省了好多 while/for, 更集中的数据流处理 )
* Guava         ( 用过就会上瘾的 google 工具库, 懒人福音 )
* Spring Boot   ( 比较懒直接集成 sb 了, 尽量会跟随最新版 )
* Spring-*      ( 这个意思就是基本在 spring 全家桶上开发 )
* Mybatis       ( 嗯, 上文已经说过了 )
* Mysql         ( 牵扯到数据库, 所以直接针对 mysql, 其他数据库请自行修改 xml 的 sql )

最后, 代码风格非常重要, 重要到可以避免自己给别人打断腿的那种.

毕竟, 代码是写给人看的, 顺便给机器执行而已.

做人还是要有点要求和追求.

That all.